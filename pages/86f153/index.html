<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>HAL结构 | Wiki：知识&amp;笔记</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/img/header32.png">
    <meta name="description" content="不再碎片化 | No longer fragmented">
    <meta name="keywords" content="个人技术博客,技术文档,学习,git,github,markdown,嵌入式,STM32,C语言">
    <meta name="theme-color" content="#11a8cd">
    <link rel="preload" href="/assets/css/0.styles.57c10a4d.css" as="style"><link rel="preload" href="/assets/js/app.287ba006.js" as="script"><link rel="preload" href="/assets/js/2.cf4362eb.js" as="script"><link rel="preload" href="/assets/js/49.a134584b.js" as="script"><link rel="prefetch" href="/assets/js/10.ca3f9f94.js"><link rel="prefetch" href="/assets/js/11.b4d1c50f.js"><link rel="prefetch" href="/assets/js/12.cca3ba79.js"><link rel="prefetch" href="/assets/js/13.e1d72f62.js"><link rel="prefetch" href="/assets/js/14.91f2adb6.js"><link rel="prefetch" href="/assets/js/15.a7a70068.js"><link rel="prefetch" href="/assets/js/16.d5be4432.js"><link rel="prefetch" href="/assets/js/17.31ec0952.js"><link rel="prefetch" href="/assets/js/18.8c0f4835.js"><link rel="prefetch" href="/assets/js/19.7cbc9836.js"><link rel="prefetch" href="/assets/js/20.e1ca69ed.js"><link rel="prefetch" href="/assets/js/21.b3b61477.js"><link rel="prefetch" href="/assets/js/22.03aa72ee.js"><link rel="prefetch" href="/assets/js/23.564ba096.js"><link rel="prefetch" href="/assets/js/24.cf195300.js"><link rel="prefetch" href="/assets/js/25.0d959a77.js"><link rel="prefetch" href="/assets/js/26.8f179dd3.js"><link rel="prefetch" href="/assets/js/27.9d4841cf.js"><link rel="prefetch" href="/assets/js/28.5c175096.js"><link rel="prefetch" href="/assets/js/29.2cb763ad.js"><link rel="prefetch" href="/assets/js/3.92b0bd34.js"><link rel="prefetch" href="/assets/js/30.eaf25d81.js"><link rel="prefetch" href="/assets/js/31.7f3c2787.js"><link rel="prefetch" href="/assets/js/32.abd8deb1.js"><link rel="prefetch" href="/assets/js/33.6c0ca3cd.js"><link rel="prefetch" href="/assets/js/34.2357e103.js"><link rel="prefetch" href="/assets/js/35.bedfc4ca.js"><link rel="prefetch" href="/assets/js/36.1fe9624d.js"><link rel="prefetch" href="/assets/js/37.6c24fb08.js"><link rel="prefetch" href="/assets/js/38.f00e5f04.js"><link rel="prefetch" href="/assets/js/39.5064abfe.js"><link rel="prefetch" href="/assets/js/4.9907f1e1.js"><link rel="prefetch" href="/assets/js/40.a7bfeb29.js"><link rel="prefetch" href="/assets/js/41.8cb7036a.js"><link rel="prefetch" href="/assets/js/42.b5ed0c1b.js"><link rel="prefetch" href="/assets/js/43.29bf753c.js"><link rel="prefetch" href="/assets/js/44.a2888a8b.js"><link rel="prefetch" href="/assets/js/45.26d4fffe.js"><link rel="prefetch" href="/assets/js/46.59abb034.js"><link rel="prefetch" href="/assets/js/47.910b85e1.js"><link rel="prefetch" href="/assets/js/48.afbe4f62.js"><link rel="prefetch" href="/assets/js/5.d0ed1372.js"><link rel="prefetch" href="/assets/js/50.3a7461e2.js"><link rel="prefetch" href="/assets/js/51.9575cb04.js"><link rel="prefetch" href="/assets/js/52.5fd5937b.js"><link rel="prefetch" href="/assets/js/53.d9b43790.js"><link rel="prefetch" href="/assets/js/54.4dd21ee3.js"><link rel="prefetch" href="/assets/js/55.6387d56f.js"><link rel="prefetch" href="/assets/js/56.05dd9dca.js"><link rel="prefetch" href="/assets/js/57.06ef5d9e.js"><link rel="prefetch" href="/assets/js/58.22dcffa8.js"><link rel="prefetch" href="/assets/js/59.f6f581db.js"><link rel="prefetch" href="/assets/js/6.e89ddaa7.js"><link rel="prefetch" href="/assets/js/60.608fdff0.js"><link rel="prefetch" href="/assets/js/61.ca910a34.js"><link rel="prefetch" href="/assets/js/62.40a51140.js"><link rel="prefetch" href="/assets/js/63.939ad5ab.js"><link rel="prefetch" href="/assets/js/64.fb28b271.js"><link rel="prefetch" href="/assets/js/65.4d6df1bd.js"><link rel="prefetch" href="/assets/js/66.0063edc7.js"><link rel="prefetch" href="/assets/js/67.bfd086a1.js"><link rel="prefetch" href="/assets/js/7.3cc1b487.js"><link rel="prefetch" href="/assets/js/8.3c2658fb.js"><link rel="prefetch" href="/assets/js/9.e346ca1c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.57c10a4d.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/head.png" alt="Wiki：知识&amp;笔记" class="logo"> <span class="site-name can-hide">Wiki：知识&amp;笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="语言学习" class="dropdown-title"><a href="/languages/" class="link-title">语言学习</a> <span class="title" style="display:none;">语言学习</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/javascript/" class="nav-link">《JavaScript教程》笔记</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础知识" class="dropdown-title"><a href="/basicknowledge/" class="link-title">基础知识</a> <span class="title" style="display:none;">基础知识</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>嵌入式</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/basicknowledge/stm32/" class="nav-link">STM32</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其他" class="dropdown-title"><a href="/others/" class="link-title">其他</a> <span class="title" style="display:none;">其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/others/9a7ee40fc232253e/" class="nav-link">技术文档</a></li></ul></div></div><div class="nav-item"><a href="/archives/" class="nav-link">归档</a></div> <a href="https://github.com/chanshu0508/wikiBase" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="语言学习" class="dropdown-title"><a href="/languages/" class="link-title">语言学习</a> <span class="title" style="display:none;">语言学习</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/javascript/" class="nav-link">《JavaScript教程》笔记</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础知识" class="dropdown-title"><a href="/basicknowledge/" class="link-title">基础知识</a> <span class="title" style="display:none;">基础知识</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>嵌入式</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/basicknowledge/stm32/" class="nav-link">STM32</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其他" class="dropdown-title"><a href="/others/" class="link-title">其他</a> <span class="title" style="display:none;">其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/others/9a7ee40fc232253e/" class="nav-link">技术文档</a></li></ul></div></div><div class="nav-item"><a href="/archives/" class="nav-link">归档</a></div> <a href="https://github.com/chanshu0508/wikiBase" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>底层&amp;寄存器</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>HAL库外设</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/67ee08/" class="sidebar-link">HAL库函数</a></li><li><a href="/pages/86f153/" aria-current="page" class="active sidebar-link">HAL结构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/86f153/#区别于标准库" class="sidebar-link">区别于标准库</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/86f153/#句柄" class="sidebar-link">句柄</a></li><li class="sidebar-sub-header"><a href="/pages/86f153/#msp函数" class="sidebar-link">MSP函数</a></li><li class="sidebar-sub-header"><a href="/pages/86f153/#回调函数" class="sidebar-link">回调函数</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/86f153/#hal库结构" class="sidebar-link">HAL库结构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/86f153/#文件结构" class="sidebar-link">文件结构</a></li><li class="sidebar-sub-header"><a href="/pages/86f153/#命名规则" class="sidebar-link">命名规则</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/86f153/#三种编程方式" class="sidebar-link">三种编程方式</a></li><li class="sidebar-sub-header"><a href="/pages/86f153/#三大回调函数" class="sidebar-link">三大回调函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/86f153/#总结" class="sidebar-link">总结</a></li></ul></li></ul></li><li><a href="/pages/6e2aa6/" class="sidebar-link">GPIO各种点亮LED</a></li><li><a href="/pages/82e74c/" class="sidebar-link">定时器</a></li><li><a href="/pages/84525e/" class="sidebar-link">PWM控制LED颜色</a></li><li><a href="/pages/5b9d30/" class="sidebar-link">按键外部中断</a></li><li><a href="/pages/93c69a/" class="sidebar-link">ADC使用</a></li><li><a href="/pages/e32c04/" class="sidebar-link">串口与DMA</a></li><li><a href="/pages/bb595a/" class="sidebar-link">FLASH 读写</a></li><li><a href="/pages/7d18a8/" class="sidebar-link">IIC通信</a></li><li><a href="/pages/b48ce4/" class="sidebar-link">SPI 通信</a></li><li><a href="/pages/2edcc2/" class="sidebar-link">CAN</a></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-33863c7e><div class="articleInfo" data-v-33863c7e><ul class="breadcrumbs" data-v-33863c7e><li data-v-33863c7e><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-33863c7e></a></li> <li data-v-33863c7e><a href="/basicknowledge/stm32" title="STM32-目录页" data-v-33863c7e>STM32</a></li> <li data-v-33863c7e><a href="/basicknowledge/stm32/#HAL库外设" title="STM32#HAL库外设" data-v-33863c7e>HAL库外设</a></li> <!----></ul> <div class="info" data-v-33863c7e><!----> <div title="创建时间" class="date iconfont icon-riqi" data-v-33863c7e><a href="javascript:;" data-v-33863c7e>2020-09-23</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">
          HAL结构
        </h1> <!----> <div class="theme-vdoing-content content__default"><blockquote><p>本文部分转载自<a href="https://blog.csdn.net/xuzhexing/article/details/90137754?biz_id=102&amp;utm_term=STM32%20%E4%B9%8B%20HAL%E5%BA%93&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-90137754&amp;spm=1018.2118.3001.4187" target="_blank" rel="noopener noreferrer">STM32 之 HAL库<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>如有侵权请联系博主删除</p></blockquote> <h2 id="区别于标准库"><a href="#区别于标准库" class="header-anchor">#</a> 区别于标准库</h2> <h3 id="句柄"><a href="#句柄" class="header-anchor">#</a> 句柄</h3> <p>相较于标准库，HAL 库中的外设可以全程挂载在一个结构体上而不是通过 <code>init</code> 函数初始化后就还是基于寄存器的操作了。这个句柄指向设定这个外设的结构体</p> <p>以 USART 为例，首先要初始化它们的各个寄存器：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">{</span>
	  USART_TypeDef                 <span class="token operator">*</span>Instance<span class="token punctuation">;</span>        <span class="token comment">/*!&lt; UART registers base address        */</span>
	  UART_InitTypeDef              Init<span class="token punctuation">;</span>             <span class="token comment">/*!&lt; UART communication parameters      */</span>
	  <span class="token class-name">uint8_t</span>                       <span class="token operator">*</span>pTxBuffPtr<span class="token punctuation">;</span>      <span class="token comment">/*!&lt; Pointer to UART Tx transfer Buffer */</span>
	  <span class="token class-name">uint16_t</span>                      TxXferSize<span class="token punctuation">;</span>       <span class="token comment">/*!&lt; UART Tx Transfer size              */</span>
	  <span class="token class-name">uint16_t</span>                      TxXferCount<span class="token punctuation">;</span>      <span class="token comment">/*!&lt; UART Tx Transfer Counter           */</span>
	  <span class="token class-name">uint8_t</span>                       <span class="token operator">*</span>pRxBuffPtr<span class="token punctuation">;</span>      <span class="token comment">/*!&lt; Pointer to UART Rx transfer Buffer */</span>
	  <span class="token class-name">uint16_t</span>                      RxXferSize<span class="token punctuation">;</span>       <span class="token comment">/*!&lt; UART Rx Transfer size              */</span>
	  <span class="token class-name">uint16_t</span>                      RxXferCount<span class="token punctuation">;</span>      <span class="token comment">/*!&lt; UART Rx Transfer Counter           */</span>  
	  DMA_HandleTypeDef             <span class="token operator">*</span>hdmatx<span class="token punctuation">;</span>          <span class="token comment">/*!&lt; UART Tx DMA Handle parameters      */</span> 
	  DMA_HandleTypeDef             <span class="token operator">*</span>hdmarx<span class="token punctuation">;</span>          <span class="token comment">/*!&lt; UART Rx DMA Handle parameters      */</span>
	  HAL_LockTypeDef               Lock<span class="token punctuation">;</span>             <span class="token comment">/*!&lt; Locking object                     */</span>
	  __IO HAL_UART_StateTypeDef    State<span class="token punctuation">;</span>            <span class="token comment">/*!&lt; UART communication state           */</span>
	  __IO <span class="token class-name">uint32_t</span>                 ErrorCode<span class="token punctuation">;</span>        <span class="token comment">/*!&lt; UART Error code                    */</span>
<span class="token punctuation">}</span>UART_HandleTypeDef<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>作为比较，如果使用标准库操作，需要的过程是这样：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>USART_InitTypeDef USART_InitStructure<span class="token punctuation">;</span>

USART_InitStructure<span class="token punctuation">.</span>USART_BaudRate <span class="token operator">=</span> bound<span class="token punctuation">;</span><span class="token comment">//串口波特率</span>
USART_InitStructure<span class="token punctuation">.</span>USART_WordLength <span class="token operator">=</span> USART_WordLength_8b<span class="token punctuation">;</span><span class="token comment">//字长为8位数据格式</span>
USART_InitStructure<span class="token punctuation">.</span>USART_StopBits <span class="token operator">=</span> USART_StopBits_1<span class="token punctuation">;</span><span class="token comment">//一个停止位</span>
USART_InitStructure<span class="token punctuation">.</span>USART_Parity <span class="token operator">=</span> USART_Parity_No<span class="token punctuation">;</span><span class="token comment">//无奇偶校验位</span>
USART_InitStructure<span class="token punctuation">.</span>USART_HardwareFlowControl <span class="token operator">=</span> USART_HardwareFlowControl_None<span class="token punctuation">;</span><span class="token comment">//无硬件数据流控制</span>
USART_InitStructure<span class="token punctuation">.</span>USART_Mode <span class="token operator">=</span> USART_Mode_Rx <span class="token operator">|</span> USART_Mode_Tx<span class="token punctuation">;</span>	<span class="token comment">//收发模式</span>

<span class="token function">USART_Init</span><span class="token punctuation">(</span>USART3<span class="token punctuation">,</span> <span class="token operator">&amp;</span>USART_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//初始化串口1</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>我们发现，与标准库不同的是，该成员不仅 :</p> <ul><li>包含了之前标准库就有的六个成员（波特率，数据格式等），</li> <li>还包含过采样、（发送或接收的）数据缓存、数据指针、串口 DMA 相关的变量、各种标志位等等要在整个项目流程中都要设置的各个成员。
<strong>该 UART1_Handler 就被称为串口的句柄，它被贯穿整个 USART 收发的流程</strong>，比如开启中断：</li></ul> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token function">HAL_UART_Receive_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>UART1_Handler<span class="token punctuation">,</span> <span class="token punctuation">(</span>u8 <span class="token operator">*</span><span class="token punctuation">)</span>aRxBuffer<span class="token punctuation">,</span> RXBUFFERSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>比如后面要讲到的 MSP 与 Callback 回调函数：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">HAL_UART_MspInit</span><span class="token punctuation">(</span>UART_HandleTypeDef <span class="token operator">*</span>huart<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">HAL_UART_RxCpltCallback</span><span class="token punctuation">(</span>UART_HandleTypeDef <span class="token operator">*</span>huart<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在这些函数中，只需要调用初始化时定义的句柄 UART1_Handler 就好</p> <h3 id="msp函数"><a href="#msp函数" class="header-anchor">#</a> MSP函数</h3> <div class="custom-block theorem"><p class="title">MSP函数</p><p>MCU Specific Package 单片机的具体方案</p></div><p><strong>MSP 是指和 MCU 相关的初始化</strong>，引用一下正点原子的解释：</p> <blockquote><p>我们要初始化一个串口，首先要设置和 MCU 无关的东西，例如波特率，奇偶校验，停止位等，这些参数设置和 MCU 没有任何关系，可以使用 STM32F1，也可以是 STM32F2/F3/F4/F7
上的串口。而一个串口设备它需要一个 MCU 来承载，例如用 STM32F4 来做承载，PA9 做为发送，PA10 做为接收，MSP 就是要初始化 STM32F4 的 PA9，PA10，配置这两个引脚</p></blockquote> <p>所以 HAL驱动方式的初始化流程就是：</p> <p><strong><code>HAL_USART_Init()</code>—&gt;<code>HAL_USART_MspInit()</code>，先初始化与 MCU 无关的串口协议，再初始化与 MCU 相关的串口引脚。</strong></p> <p>在 STM32 的 HAL 驱动中 <code>HAL_PPP_MspInit()</code>作为回调，被 <code>HAL_PPP_Init()</code> 函数所调用。当我们需要移植程序到 STM32F1 平台的时候，我们只需要修改 <code>HAL_PPP_MspInit</code> 函数内容而不需要修改 <code>HAL_PPP_Init</code>入口参数内容</p> <p>在 HAL 库中，几乎每初始化一个外设就需要设置该外设与单片机之间的联系，比如 IO 口，是否复用等等，可见，HAL 库相对于标准库多了 MSP 函数之后，移植性非常强，但与此同时却增加了代码量和代码的嵌套层级。可以说各有利弊。</p> <p>同样，MSP 函数又可以配合句柄，达到非常强的移植性：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>void HAL_UART_MspInit(UART_HandleTypeDef *huart);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>入口参数仅仅需要一个串口句柄，这样有能看出句柄的方便。</p> <h3 id="回调函数"><a href="#回调函数" class="header-anchor">#</a> 回调函数</h3> <p>还是以 USART 为例，在<strong>标准库</strong>中，串口中断了以后，我们要先在中断中判断是否是接收中断，然后读出数据，顺便清除中断标志位，然后再是对数据的处理，这样如果我们在一个中断函数中写这么多代码，就会显得很混乱：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">USART3_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>                	<span class="token comment">//串口1中断服务程序</span>
<span class="token punctuation">{</span>
	u8 Res<span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">USART_GetITStatus</span><span class="token punctuation">(</span>USART3<span class="token punctuation">,</span> USART_IT_RXNE<span class="token punctuation">)</span> <span class="token operator">!=</span> RESET<span class="token punctuation">)</span>  <span class="token comment">//接收中断(接收到的数据必须是0x0d 0x0a结尾)</span>
	<span class="token punctuation">{</span>
		Res <span class="token operator">=</span><span class="token function">USART_ReceiveData</span><span class="token punctuation">(</span>USART3<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//读取接收到的数据</span>
		<span class="token comment">/*数据处理区*/</span>
		<span class="token punctuation">}</span>   		 
     <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>而在 HAL 库中，进入串口中断后，直接由 <strong>HAL 库中断函数</strong>进行托管：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">USART1_IRQHandler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>                	
<span class="token punctuation">{</span> 
    <span class="token comment">/*By the way，这个函数就是中断发生后的入口函数*/</span>
	<span class="token function">HAL_UART_IRQHandler</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>UART1_Handler<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//调用HAL库串口中断处理公用函数</span>
	<span class="token comment">/***************省略无关代码****************/</span>	
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><code>HAL_UART_IRQHandler</code>这个函数完成了判断是哪个中断（接收？发送？或者其他），然后<strong>读出数据</strong>，<strong>保存至缓存区</strong>，顺便<strong>清除中断标志位</strong>等等操作。
比如我提前设置了，串口每接收五个字节，我就要对这五个字节进行处理。
在一开始我定义了一个串口接收缓存区：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">/*HAL库使用的串口接收缓冲,处理逻辑由HAL库控制，接收完这个数组就会调用HAL_UART_RxCpltCallback进行处理这个数组*/</span>
<span class="token comment">/*RXBUFFERSIZE=5*/</span>
u8 aRxBuffer<span class="token punctuation">[</span>RXBUFFERSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在初始化中，我在句柄里设置好了缓存区的地址，缓存大小（五个字节）</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">/*该代码在HAL_UART_Receive_IT函数中，初始化时会引用*/</span>
	huart<span class="token operator">-&gt;</span>pRxBuffPtr <span class="token operator">=</span> pData<span class="token punctuation">;</span><span class="token comment">//aRxBuffer</span>
    huart<span class="token operator">-&gt;</span>RxXferSize <span class="token operator">=</span> Size<span class="token punctuation">;</span><span class="token comment">//RXBUFFERSIZE</span>
    huart<span class="token operator">-&gt;</span>RxXferCount <span class="token operator">=</span> Size<span class="token punctuation">;</span><span class="token comment">//RXBUFFERSIZE</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>则在接收数据中，每接收完五个字节，<code>HAL_UART_IRQHandler</code> 才会执行一次 Callback 函数：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">HAL_UART_RxCpltCallback</span><span class="token punctuation">(</span>UART_HandleTypeDef <span class="token operator">*</span>huart<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在这个 Callback 回调函数中，我们只需要对这接收到的五个字节（保存在 <code>aRxBuffer[]</code> 中）进行处理就好了，完全不用再去手动清除标志位等操作。
所以说 <strong>Callback 函数是一个应用层代码的函数</strong>，我们在一开始只设置句柄里面的各个参数，然后就等着 HAL 库把自己安排好的代码送到手中就可以了~</p> <p>综上，从这三个小点就可以看出 HAL 库的可移植性之强大，并且用户可以完全不去理会底层各个寄存器的操作，代码也更有逻辑性。但与此带来的是复杂的代码量，极慢的编译速度，略微低下的效率。看怎么取舍了</p> <h2 id="hal库结构"><a href="#hal库结构" class="header-anchor">#</a> HAL库结构</h2> <h3 id="文件结构"><a href="#文件结构" class="header-anchor">#</a> 文件结构</h3> <div align="center"><img src="https://cdn.jsdelivr.net/gh/CHANShu0508/images_shack/images/20200923183517.png"></div> <ul><li><p><strong><code>stm32f4xx.h</code></strong> 主要包含 STM32 同系列芯片的不同具体型号的定义，是否使用 HAL 库等的定义，接着，其会根据定义的芯片信号包含具体的芯片型号的头文件：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>STM32F405xx<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;stm32f405xx.h&quot;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>STM32F415xx<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;stm32f415xx.h&quot;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>STM32F407xx<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;stm32f407xx.h&quot;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>STM32F417xx<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;stm32f417xx.h&quot;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">error</span> <span class="token string">&quot;Please select first the target STM32F4xx device used in your application (in stm32f2xx.h file)&quot;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>紧接着，其会包含 stm32f4xx_hal.h：</p></li> <li><p><strong><code>stm32f4xx_hal.h</code></strong>：<code>stm32f4xx_hal.c/h</code> 主要实现 HAL 库的初始化、系统滴答相关函数、及 CPU 的调试模式配置</p></li> <li><p><strong><code>stm32f4xx_hal_conf.h</code></strong>：该文件是一个用户级别的配置文件，用来实现对 HAL 库的裁剪，其位于用户文件目录，不要放在库目录中</p></li></ul> <p>接下来对于 HAL 库的源码文件进行一下说明，HAL 库文件名均以 stm32f4xx_hal 开头，后面加上 _ 外设或者模块名（如：stm32f4xx_hal_adc.c）：</p> <ul><li><strong>库文件：</strong> <ul><li><strong><code>stm32f4xx_hal_ppp.c/.h</code></strong> ：主要的外设或者模块的驱动源文件，包含了该外设的通用 API
<strong>stm32f4xx_hal_ppp_ex.c/.h</strong> // 外围设备或模块驱动程序的扩展文件。这组文件中包含特定型号或者系列的芯片的特殊 API。以及如果该特定的芯片内部有不同的实现方式，则该文件中的特殊 API 将覆盖 _ppp 中的通用 API</li> <li><strong><code>stm32f4xx_hal.c/.h</code></strong>：此文件用于 HAL 初始化，并且包含 DBGMCU、重映射和基于 systick 的时间延迟等相关的 API</li></ul></li> <li><strong>其他库文件</strong>：
<ul><li>用户级别文件：
<ul><li><strong><code>stm32f4xx_hal_msp_template.c</code></strong>： 只有 <code>.c</code>没有 <code>.h</code>。它包含用户应用程序中使用的外设的 MSP 初始化和反初始化（主程序和回调函数）。使用者复制到自己目录下使用模板</li> <li><strong><code>stm32f4xx_hal_conf_template.h</code></strong>： 用户级别的库配置文件模板。使用者复制到自己目录下使用</li> <li><strong><code>system_stm32f4xx.c</code></strong>：此文件主要包含 <code>SystemInit()</code> 函数，该函数在刚复位及跳到 main 之前的启动过程中被调用。<strong>它不在启动时配置系统时钟（与标准库相反）</strong>。时钟的配置在用户文件中使用 HAL API 来完成</li> <li><strong><code>startup_stm32f4xx.s</code></strong>：芯片启动文件，主要包含堆栈定义，终端向量表等</li> <li><strong><code>stm32f4xx_it.c/.h</code></strong>：中断处理函数的相关实现</li></ul></li></ul></li> <li><strong><code>main.c/.h</code></strong></li></ul> <h3 id="命名规则"><a href="#命名规则" class="header-anchor">#</a> 命名规则</h3> <p>根据 HAL 库的命名规则，其 API 可以分为以下三大类：</p> <ul><li><strong>初始化 / 反初始化函数</strong>：<code>HAL_PPP_Init()</code>, <code>HAL_PPP_DeInit()</code></li> <li><strong>IO 操作函数</strong>：<code>HAL_PPP_Read()</code>, <code>HAL_PPP_Write()</code>, <code>HAL_PPP_Transmit()</code>, <code>HAL_PPP_Receive()</code></li> <li><strong>控制函数</strong>：<code>HAL_PPP_Set ()</code>, <code>HAL_PPP_Get ()</code></li> <li><strong>状态和错误</strong> :  <code>HAL_PPP_GetState ()</code>, <code>HAL_PPP_GetError ()</code></li></ul> <h2 id="三种编程方式"><a href="#三种编程方式" class="header-anchor">#</a> 三种编程方式</h2> <p>HAL 库对所有的函数模型也进行了统一。在 HAL 库中，支持三种编程模式：<strong>轮询模式、中断模式、DMA 模式</strong>（如果外设支持）。其分别对应如下三种类型的函数（以 ADC 为例）：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>HAL_StatusTypeDef <span class="token function">HAL_ADC_Start</span><span class="token punctuation">(</span>ADC_HandleTypeDef<span class="token operator">*</span> hadc<span class="token punctuation">)</span><span class="token punctuation">;</span>
HAL_StatusTypeDef <span class="token function">HAL_ADC_Stop</span><span class="token punctuation">(</span>ADC_HandleTypeDef<span class="token operator">*</span> hadc<span class="token punctuation">)</span><span class="token punctuation">;</span>

HAL_StatusTypeDef <span class="token function">HAL_ADC_Start_IT</span><span class="token punctuation">(</span>ADC_HandleTypeDef<span class="token operator">*</span> hadc<span class="token punctuation">)</span><span class="token punctuation">;</span>
HAL_StatusTypeDef <span class="token function">HAL_ADC_Stop_IT</span><span class="token punctuation">(</span>ADC_HandleTypeDef<span class="token operator">*</span> hadc<span class="token punctuation">)</span><span class="token punctuation">;</span>

HAL_StatusTypeDef <span class="token function">HAL_ADC_Start_DMA</span><span class="token punctuation">(</span>ADC_HandleTypeDef<span class="token operator">*</span> hadc<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span><span class="token operator">*</span> pData<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> Length<span class="token punctuation">)</span><span class="token punctuation">;</span>
HAL_StatusTypeDef <span class="token function">HAL_ADC_Stop_DMA</span><span class="token punctuation">(</span>ADC_HandleTypeDef<span class="token operator">*</span> hadc<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>其中，<strong>带 _IT 的表示工作在中断模式下</strong>；<strong>带 _DMA 的工作在 DMA 模式下</strong>（注意：DMA 模式下也是开中断的）：<strong>什么都没带的就是轮询模式</strong>（没有开启中断的）。至于使用者使用何种方式，就看自己的选择了</p> <p>此外，新的 HAL 库架构下统一采用宏的形式对各种中断等进行配置（原来标准外设库一般都是各种函数）。针对每种外设主要由以下宏：</p> <ul><li><code>__HAL_PPP_ENABLE_IT(HANDLE, INTERRUPT)</code>：使能一个指定的外设中断</li> <li><code>__HAL_PPP_DISABLE_IT(HANDLE, INTERRUPT)</code>：失能一个指定的外设中断</li> <li><code>__HAL_PPP_GET_IT (HANDLE, __ INTERRUPT __)</code>：获得一个指定的外设中断状态</li> <li><code>__HAL_PPP_CLEAR_IT (HANDLE, __ INTERRUPT __)</code>：清除一个指定的外设的中断状态</li> <li><code>__HAL_PPP_GET_FLAG (HANDLE, FLAG)</code>：获取一个指定的外设的标志状态</li> <li><code>__HAL_PPP_CLEAR_FLAG (HANDLE, FLAG)</code>：清除一个指定的外设的标志状态</li> <li><code>__HAL_PPP_ENABLE(HANDLE)</code>：使能外设</li> <li><code>__HAL_PPP_DISABLE(HANDLE)</code>：失能外设</li> <li><code>__HAL_PPP_XXXX (HANDLE, PARAM)</code>：指定外设的宏定义</li> <li><code>__HAL_PPP_GET_IT_SOURCE (HANDLE, __ INTERRUPT __)</code>：检查中断源</li></ul> <h2 id="三大回调函数"><a href="#三大回调函数" class="header-anchor">#</a> 三大回调函数</h2> <p>在 HAL 库的源码中，到处可见一些以 <code>__weak</code>开头的函数，而且这些函数，有些已经被实现了，比如：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>__weak HAL_StatusTypeDef <span class="token function">HAL_InitTick</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> TickPriority<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">/*Configure the SysTick to have interrupt in 1ms time basis*/</span>
	<span class="token function">HAL_SYSTICK_Config</span><span class="token punctuation">(</span>SystemCoreClock<span class="token operator">/</span><span class="token number">1000U</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">/*Configure the SysTick IRQ priority */</span>
	<span class="token function">HAL_NVIC_SetPriority</span><span class="token punctuation">(</span>SysTick_IRQn<span class="token punctuation">,</span> TickPriority <span class="token punctuation">,</span><span class="token number">0U</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">/* Return function status */</span>
	<span class="token keyword">return</span> HAL_OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>有些则没有被实现，例如：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>__weak <span class="token keyword">void</span> <span class="token function">HAL_SPI_TxCpltCallback</span><span class="token punctuation">(</span>SPI_HandleTypeDef <span class="token operator">*</span>hspi<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">/* Prevent unused argument(s) compilation warning */</span>
  <span class="token function">UNUSED</span><span class="token punctuation">(</span>hspi<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* NOTE : This function should not be modified, when the callback is needed,the HAL_SPI_TxCpltCallback should be implemented in the user file
  */</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>所有带有 <code>__weak</code> 关键字的函数表示，就可以由用户自己来实现。如果出现了同名函数，且不带 <code>__weak</code> 关键字，那么连接器就会采用外部实现的同名函数。
通常来说，HAL 库负责整个处理和 MCU 外设的处理逻辑，并将必要部分以回调函数的形式给出到用户，用户只需要在对应的回调函数中做修改即可。HAL 库包含如下三种用户级别回调函数（PPP 为外设名）：</p> <ul><li><p><strong>外设系统级初始化 / 解除初始化回调函数</strong>（用户代码的第二大部分：对于 MSP 的处理）：<code>HAL_PPP_MspInit()</code> 和 <code>HAL_PPP_MspDeInit</code></p> <blockquote><p>例如：<code>__weak void HAL_SPI_MspInit(SPI_HandleTypeDef *hspi)</code></p></blockquote> <p>在 <code>HAL_PPP_Init()</code> 函数中被调用，用来初始化底层相关的设备（GPIOs, clock, DMA, interrupt）</p></li> <li><p><strong>处理完成回调函数</strong>：<code>HAL_PPP_ProcessCpltCallback*</code>（Process 指具体某种处理，如 UART 的 Tx）</p> <blockquote><p>例如：<code>__weak void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)</code></p></blockquote> <p>当外设或者 DMA 工作完成后时，触发中断，该回调函数会在外设中断处理函数或者 DMA 的中断处理函数中被调用</p></li> <li><p><strong>错误处理回调函数</strong>：<code>HAL_PPP_ErrorCallback</code></p> <blockquote><p>例如：<code>__weak void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)</code></p></blockquote> <p>当外设或者 DMA 出现错误时，触发终端，该回调函数会在外设中断处理函数或者 DMA 的中断处理函数中被调用</p></li></ul> <p><strong>绝大多数用户代码均在以上三大回调函数中实现。</strong></p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>HAL 库结构中，在每次初始化前（尤其是在多次调用初始化前），先调用对应的<strong>反初始化</strong>（DeInit）函数是非常有必要的。
某些外设多次初始化时不调用返回会导致初始化失败。完成回调函数有多中，例如串口的完成回调函数有<code>HAL_UART_TxCpltCallback</code> 和 <code>HAL_UART_TxHalfCpltCallback</code> 等
（用户代码的第三大部分：对于上面第二点和第三点的各种回调函数的处理）
在实际使用中，发现 HAL 仍有不少问题，例如在使用 USB 时，其库配置存在问题</p></div></div> <!----> <div class="page-edit"><div class="edit-link"><a href="https://github.com/chanshu0508/wikiBase/edit/master/docs/STM32/05.HAL库外设/01.HAL结构.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2020/11/18, 13:11:00</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/67ee08/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">HAL库函数</div></a> <a href="/pages/6e2aa6/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">GPIO各种点亮LED</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/67ee08/" class="prev">HAL库函数</a></span> <span class="next"><a href="/pages/6e2aa6/">GPIO各种点亮LED</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><!----> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2020-2021
    <span>Jack :) | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">跟随系统</li><li class="iconfont icon-rijianmoshi">浅色模式</li><li class="iconfont icon-yejianmoshi">深色模式</li><li class="iconfont icon-yuedu">阅读模式</li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.287ba006.js" defer></script><script src="/assets/js/2.cf4362eb.js" defer></script><script src="/assets/js/49.a134584b.js" defer></script>
  </body>
</html>