## 函数

### 阻塞式发送函数

特点：发送时没有发完单片机不能执行其他工作

```c
HAL_StatusTypeDef  HAL_UART_Transmit(UART_HandleTypeDef *huart,uint8_t *pData,uint16_t Size, uint32_t Timeout);

//参数1：huart，串口实例的指针
//参数2：*pData，待发送数据缓冲区的指针
//参数3：Size，待发送数据的字节数
//参数4：Timeout，超时时间值
//返回值：HAL_StatusTypeDef，函数执行状态。
```

如果超出超时时间值，会自己结束以免打扰其他进程

### 非阻塞式发送函数

```c
HAL_StatusTypeDef  HAL_UART_Transmit_IT(UART_HandleTypeDef *huart,uint8_t *pData, uint16_t Size);

//参数1：huart，串口实例的指针
//参数2：*pData，待发送数据缓冲区的指针
//参数3：Size，待发送数据的字节数
//返回值：HAL_StatusTypeDef，函数执行状态

////串口发送完毕中断回调函数  
void HAL_UART_TxCpltCallback(UART_HandleTypeDef  *huart);
void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef  *huart)  //发完一半进入
```

发送完之后，会进入发送完中断

运行示例：

```c
HAL_UART_Transmit_IT(&huart1,  dat_Txd, 5);

void HAL_UART_TxCpltCallback(UART_HandleTypeDef  *huart) 
{         
    if(huart->Instance == USART1);         
    {             
        HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_9);    
    }
}
```

判断句柄是否正确的`huart->Instance`是它的基地址

### 非阻塞式接收函数

```c
HAL_StatusTypeDef  HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData,  uint16_t Size, uint32_t Timeout);

//参数1：huart，串口实例的指针
//参数2：*pData，数据接收据缓冲区的指针
//参数3：Size，待接收数据的字节数
//参数4：Timeout，超时时间值
//返回值：HAL_StatusTypeDef，函数执行状态
```

不推荐使用，因为发来数据的对象发送的时间不可控，但你的时间是确定的

### 阻塞式接收函数

```c
HAL_StatusTypeDef  HAL_UART_Receive_IT(UART_HandleTypeDef *huart,uint8_t *pData,uint16_t Size);

//参数1：huart，串口实例的指针。
//参数2：*pData，数据接收据缓冲区的指针。
//参数3：Size，待接收数据的字节数。
//返回值：HAL_StatusTypeDef，函数执行状态。

////串口接收完毕中断回调函数
void HAL_UART_RxCpltCallback(UART_HandleTypeDef  *huart);
void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef  *huart);
```

接收完之后，会进入接收完中断

运行实例：

```c
//使用中断，非阻塞方式
HAL_UART_Transmit_IT(&huart1,  &dat_Rxd, 1);
  
void HAL_UART_RxCpltCallback(UART_HandleTypeDef  *huart)    
{        
    if(huart->Instance == USART1)    
    {       
        if(dat_Rxd == 0x5A)      
            HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_8);
    }
}
```

接收完一个字节就中断

## 实例

我们循序渐进的用不同等级的代码来实现板间的串口通信

### 阻塞式发送与非阻塞式接收

```c
/*
  @brief  简单的串口通信
  @type   使用阻塞式发送与非阻塞式接收
  @coding UTF-8
*/

//// main 之前的内容
// 定义简单的LED开闭宏
#define LEDx_ON() HAL_GPIO_WritePin(GPIOx, GPIO_PINx, GPIO_PIN_SET)
#define LEDx_OFF() HAL_GPIO_WritePin(GPIOx, GPIO_PINx, GPIO_PIN_RESET)
// 收发使用的数组与数字
uint8_t Tx_str1[] = "LEDx is opened.\r\n";
uint8_t Tx_str2[] = "LEDx is cloesd.\r\n";
uint8_t Rx_data = 0;

//// 回调函数
void HAL_UART_RxCpltCallback(UART_HAndleTypeDef *huart)
{
	if (Rx_data == 0xa1)
	{
		LEDx_ON();
		HAL_UART_Transmait(&huart1, Tx_str1, sizeof(Tx_str1), 10000);
		// @注意1
		HAL_UART_Receive_IT(&huart, &Rx_data, 1);
	}
	else if (Rx_data == 0xa2)
	{
		LEDx_OFF();
		HAL_UART_Transmait(&huart1, Tx_str2, sizeof(Tx_str2), 10000);
		// @注意1
		HAL_UART_Receive_IT(&huart, &Rx_data, 1);
	}
}

//// main中的自定义内容
int main()
{
	// forward
	// 启动接受中断（非阻塞式接收函数）
	HAL_UART_Receive_IT(&huart1, &Rx_data, 1);
	// later
}
```

这段函数的作用就是使能了串口1，也就是 `UART1` 的接收中断，接受传入到串口1的信息，并且每接受一个数据帧（长度可设置，一般为8bit，也就是两位16进制数）之后发生中断

在中断中，检测这个发来的2位16进制数，如果大小为 `0xa1` 则打开 LED，并向信息来源发送“LED is opened”；如果大小是 `0xa2` 则关闭 LED，并向信息来源发送“LED is closed”。

::: warning 注意解析
1. 在接收中断，也就是`HAL_UART_Receive_IT()` 作用过一次之后，他就失效了，也就是这一句函数只管使用一次接收
:::