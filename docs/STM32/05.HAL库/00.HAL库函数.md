---
title: HAL库函数
date: 2020-08-20 18:09:51
permalink: /pages/67ee08/
---
**学习库函数最好的方法是看手册**

## HAL库

### HAL_Delay

HAL 库提供了用于毫秒级延迟的函数：HAL_Delay 函数（使用`_weak` 修饰符说明该函数是可以用户重定义的）

```c
__weak void HAL_Delay(uint32_t Delay)
```

| 函数名   | HAL_Delay                                       |
| -------- | ----------------------------------------------- |
| 函数作用 | 使系统延迟对应的毫秒级时间                      |
| 返回值   | void                                            |
| 参数     | Delay，对应的延迟毫秒数，比如延迟 1 秒就为 1000 |

### HAL_GetTick

`uwTick`变量中存储的是从STM32的 Systick 初始化以来所经过的时间（ms），`uwTick`的存在相当于给整个程序提供了一个绝对的时间基准，访问其值可用如下函数：

| 函数名   | HAL_GetTick          |
| -------- | -------------------- |
| 函数作用 | 返回当前的`uwTick`值 |
| 返回值   | 当前的`uwTick`值     |

## GPIO 操作

### HAL_GPIO_WritePin

定义如下：

```c
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
```

| 函数名               | HAL_GPIO_WritePin                                          |
| :------------------- | :--------------------------------------------------------- |
| 函数作用             | 使得对应的引脚输出高电平或者低电平                         |
| 返回值               | void                                                       |
| 参数 1：GPIOx        | 对应 GPIO 总线，其中 x 可以是 A…I。例如 PH10，则输入 GPIOH |
| 参数 2：GPIO_Pin     | 对应引脚数，可以是 0-15。例如 PH10，则输入 GPIO_PIN_10     |
| **参数 3：PinState** | `GPIO_PIN_RESET`：输出低电平；`GPIO_PIN_SET`：输出高电平   |

### HAL_GPIO_TogglePin

定义如下：

```c
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
```

| 函数名           | HAL_GPIO_TogglePin                                         |
| ---------------- | ---------------------------------------------------------- |
| 函数作用         | 翻转对应引脚的电平                                         |
| 返回值           | void                                                       |
| 参数 1：GPIOx    | 对应 GPIO 总线，其中 x 可以是 A…I。例如 PH10，则输入 GPIOH |
| 参数 2：GPIO_Pin | 对应引脚数。可以是 0-15。例如 PH10，则输入 GPIO_PIN_10     |

### HAL_GPIO_ReadPin

定义如下：

```c
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
```

| 函数名   | HAL_GPIO_ReadPin                                             |
| -------- | ------------------------------------------------------------ |
|函数作用| 返回引脚电平 |
| 返回值    | GPIO_PinState，如果是高电平则返回`GPIO_PIN_SET`（对应为1），如果是低电平则返回`GPIO_PIN_RESET`（对应为0） |
| 参数 1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   | 对应 GPIO 总线，其中 x 可以是 A…I。例如 PH10，则输入 GPIOH   |
| 参数 2   | 对应引脚数。可以是 0-15。例如 PH10，则输入 GPIO_PIN_10       |

## 定时器操作

### HAL_TIM_IRQHandler

```c
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
```

| 函数名   | HAL_TIM_IRQHandler                                           |
| -------- | ------------------------------------------------------------ |
| 函数作用 | HAL对涉及（定时器）中断的寄存器进行处理                      |
| 返回值   | void                                                         |
| 参数     | `*htim` 定时器的句柄指针，如定时器1就输入`&htim1`，定时器2就输入`&htim2` |

在这个函数对寄存器进行配置之后，程序将会自动调用中断回调函数

```c
_weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
```

和上面一样，它的参数也是定时器的句柄指针。我们在`main.c`中就是需要重新将**中断的内容**写入这个回调函数，定时器中断更多请内容查看[此处](/pages/82e74c/)

### HAL_TIM_Base_Start

如果不开启中断，仅让定时器以定时功能工作，为了使定时器开始工作，需要调用HAL库提供的函数

```c
HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
```

| 函数名   | HAL_TIM_Base_Start                                           |
| -------- | ------------------------------------------------------------ |
| 函数作用 | 使对应的定时器开始工作                                       |
| 返回值   | HAL_StatusTypeDef，HAL库定义的几种状态，如果成功使定时器开始工作，则返回`HAL_OK` |
| 参数     | `*htim` 定时器的句柄指针，如定时器1就输入`&htim1`，定时器2就输入`&htim2` |

此函数需要在主循环`while(1)`之前调用

### HAL_TIM_Base_Start_IT

接上面的函数，如果不仅需要开启定时器，还需要使用定时中断，则需要调用此函数

```c
HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
```

| 函数名   | HAL_TIM_Base_Start_IT                                        |
| :------- | :----------------------------------------------------------- |
| 函数作用 | 使对应的定时器开始工作，并使能其定时中断                     |
| 返回值   | HAL_StatusTypeDef，HAL库定义的几种状态，如果成功使定时器开始工作，则返回HAL_OK |
| 参数     | `*htim` 定时器的句柄指针，如定时器1就输入`&htim1`，定时器2就输入`&htim2` |

此函数也需要在主循环`while(1)`之前调用

### __HAL_TIM_SetCompare

这是在定时器进行 PWM 输出的时候，对储存比较值的寄存器 TIMx_CCRx 赋值的函数

```c
#define __HAL_TIM_SET_COMPARE(__HANDLE__, __CHANNEL__, __COMPARE__) \
(((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCR1 = (__COMPARE__)) :\
((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCR2 = (__COMPARE__)) :\
((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCR3 = (__COMPARE__)) :\
((__HANDLE__)->Instance->CCR4 = (__COMPARE__)))
```

| 函数名            | __HAL_TIM_SetCompare                                         |
| :---------------- | ------------------------------------------------------------ |
| 函数作用        | 在程序运行时对储存比较值的寄存器 TIMx_CCRx 赋值，修改比较值     |
| 参数1 | 输入`*htim` 定时器的句柄指针即可，如定时器1就输入`&htim1`，定时器2就输入`&htim2` |
| 参数2 | 定时器的频道号，如`TIM_CHANNEL_1`, `TIM_CHANNEL_2`           |
| 参数3 | 要赋给 TIMx_CCRx 寄存器的值，此值要小于 TIMx_ARR 内的重装载值 |

### __HAL_TIM_PRESCALER

其实它和 `__HAL_TIM_SET_PRESCALER`是等效的，因为此句：

```c
#define __HAL_TIM_PRESCALER    __HAL_TIM_SET_PRESCALER
```

但其原始定义为：

```c
#define __HAL_TIM_SET_PRESCALER(__HANDLE__, __PRESC__)       ((__HANDLE__)->Instance->PSC = (__PRESC__))
```

| 函数名   | __HAL_TIM_PRESCALER                                          |
| :------- | ------------------------------------------------------------ |
| 函数作用 | 在程序运行时对储存预分频比的寄存器 TIMx_PSR 赋值，修改预分频比 |
| 参数1    | 输入`*htim` 定时器的句柄指针即可，如定时器1就输入`&htim1`，定时器2就输入`&htim2` |
| 参数2    | 要赋给 TIMx_PSR 寄存器的新预分频比值                         |

### HAL_TIM_PWM_Start

HAL库提供的PWM初始化函数，为定时器初始化 PWM

| 函数名   | HAL_TIM_PWM_Start                                            |
| :------- | ------------------------------------------------------------ |
| 函数作用 | 使对应定时器的对应通道开始PWM输出                            |
| 返回值   | HAL_StatusTypeDef，HAL库定义的几种状态，如果成功使定时器开始工作，则返回`HAL_OK` |
| 参数1    | `*htim`定时器的句柄指针，如定时器1就输入`&htim1`，定时器2就输入`&htim2` |
| 参数2    | Channel 定时器PWM输出的通道，比如通道1为`TIM_CHANNEL1`       |

## 中断返回函数

### HAL_TIM_PeriodElapsedCallback

这是定时器中断的回调函数，其原始定义为：

```c
__weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
```

我们需要在`main.c`或其他我们自己的位置重新定义其内容

| 函数名   | HAL_TIM_PeriodElapsedCallback                                |
| :------- | ------------------------------------------------------------ |
| 函数作用 | 定义定时器中断的中断执行内容                                 |
| 返回值   | void                                                         |
| 参数1    | 发生定时器中断的定时器句柄指针，是由系统在调用时自动填写的；如 `&htim1`, `&htim2` 等 |

### HAL_GPIO_EXIT_Callback

这是 GPIO 外部中断的回调函数，其原始定义为：

```c
__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
```

我们需要在`main.c`或其他我们自己的位置重新定义其内容

| 函数名   | HAL_GPIO_EXIT_Ballback                                       |
| :------- | ------------------------------------------------------------ |
| 函数作用 | 定义 GPIO 外部中断的中断执行内容                             |
| 返回值   | void                                                         |
| 参数1    | 发生外部中断的引脚(组)号，是由系统在调用时自动填写的；如 PA0, PB1 等 |